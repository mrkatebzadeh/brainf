{
    "docs": [
        {
            "location": "/", 
            "text": "BrainF Compiler and Interpreter\n\n\nWelcome to BrainF Compiler and Interpreter documentation.\nFor more infromation about me please visit my homepage \nmrkatebzadeh.xyz\n.\n\n\nWhat is BrainF\n\n\nBrainF\n is the ungodly creation of Urban M\u00fcller. It is proven to be \nturing-complete\n and very simple as go lang. BrainF operates on an array of memory cells, also referred to as the tape, each initially set to zero. There is a pointer, initially pointing to the first memory cell. The commands are:\n\n\n\n\n\n\n\n\nCommand\n\n\nDescription\n\n\nEquivalent\n\n\n\n\n\n\n\n\n\n\n\n\nMove the pointer to the right\n\n\n++ptr\n\n\n\n\n\n\n\n\nMove the pointer to the left\n\n\n--ptr\n\n\n\n\n\n\n+\n\n\nIncrement the memory cell under the pointer\n\n\n++*ptr\n\n\n\n\n\n\n-\n\n\nDecrement the memory cell under the pointer\n\n\n--*ptr\n\n\n\n\n\n\n.\n\n\nOutput the character signified by the cell at the pointer\n\n\nputchar(*ptr)\n\n\n\n\n\n\n,\n\n\nInput a character and store it in the cell at the pointer\n\n\n*ptr = getchar()\n\n\n\n\n\n\n[\n\n\nJump past the matching ] if the cell under the pointer is 0\n\n\nwhile (*ptr) {\n\n\n\n\n\n\n]\n\n\nJump back to the matching [ if the cell under the pointer is nonzero\n\n\n}\n\n\n\n\n\n\n\n\nThis program prints out the words \nHello World!\n:\n\n\n+++++ +++             Set Cell #0 to 8\n[\n  \n++++               Add 4 to Cell #1; this will always set Cell #1 to 4\n  [                   as the cell will be cleared by the loop\n      \n++             Add 4*2 to Cell #2\n      \n+++            Add 4*3 to Cell #3\n      \n+++            Add 4*3 to Cell #4\n      \n+              Add 4 to Cell #5\n      \n-           Decrement the loop counter in Cell #1\n  ]                   Loop till Cell #1 is zero\n  \n+                  Add 1 to Cell #2\n  \n+                  Add 1 to Cell #3\n  \n-                  Subtract 1 from Cell #4\n  \n+                 Add 1 to Cell #6\n  [\n]                 Move back to the first zero cell you find; this will\n                      be Cell #1 which was cleared by the previous loop\n  \n-                  Decrement the loop Counter in Cell #0\n]                     Loop till Cell #0 is zero\n\nThe result of this is:\nCell No :   0   1   2   3   4   5   6\nContents:   0   0  72 104  88  32   8\nPointer :   ^\n\n\n.                     Cell #2 has value 72 which is 'H'\n\n---.                   Subtract 3 from Cell #3 to get 101 which is 'e'\n+++++ ++..+++.          Likewise for 'llo' from Cell #3\n\n.                     Cell #5 is 32 for the space\n\n-.                     Subtract 1 from Cell #4 for 87 to give a 'W'\n\n.                      Cell #3 was set to 'o' from the end of 'Hello'\n+++.----- -.----- ---.  Cell #3 for 'rl' and 'd'\n\n+.                    Add 1 to Cell #5 gives us an exclamation point\n\n++.                    And finally a newline from Cell #6\n\n\n\n\nWe have a simple and fast interpreter and a complete compiler for BrainF.\nThe compiling phase is structured as follows:\n\n\nBF source -\n BF IR -\n LLVM IR -\n x86_32 Binary\n\n\n\n\nGetting started\n\n\nGetting started is super easy. You can clone the repository:\n\n\n$ git clone https://github.com/mrkatebzadeh/brainf_compiler.git\n\n\n\n\nUsage\n\n\nYou will need LLVM and Rust installed to compile brainf_compiler.\n\n\n$ cargo build --release\n\n\n\n\nDebug builds work, but large BF programs will take a long time\nin speculative execution if brainf_compiler is compiled without optimizations. You\ncan disable this by passing \n--opt=0\n or \n--opt=1\n when running brainf_compiler.\n\n\nCompiling-mode:\n\n\n$ target/release/brainf_compiler -c samples/hello_world.bf\n$ ./hello_world\nHello World!\n\n\n\n\nInterpreting-mode:\n\n\n$ target/release/brainf_compiler -i samples/hello_world.bf\nHello World!\n\n\n\n\nBy default, brainf_compiler compiles programs to executables that run on the\ncurrent machine. You can explicitly specify architecture using LLVM\ntarget triples:\n\n\n$ target/release/brainf_compiler -c samples/hello_world.bf --target=x86_64-pc-linux-gnu\n\n\n\n\nLLVM Version\n\n\nLLVM 3.8+ is recommended, as there are known bugs with 3.7. Either\ndownload a prebuilt LLVM, or build it as follows:\n\n\n$ wget http://llvm.org/pre-releases/3.8.0/rc1/llvm-3.8.0rc1.src.tar.xz\n$ tar -xf llvm-3.8.0rc1.src.tar.xz\n\n$ mkdir -p ~/tmp/llvm_3_8_build\n$ cd ~/tmp/llvm_3_8_build\n\n$ cmake -G Ninja /path/to/untarred/llvm\n$ ninja\n\n\n\n\nbrainf_compiler depends on llvm-sys, which compiles against whichever\n\nllvm-config\n it finds.\n\n\n$ export PATH=~/tmp/llvm_3_8_build:$PATH\n$ cargo build --release\n\n\n\n\nPortability\n\n\nbrainf_compiler considers cells to be single bytes, and arithmetic wraps\naround. As a result, \n-\n sets cell #0 to 255.\n\n\nbrainf_compiler provides 100,000 cells. Accessing cells outside of this range is\nexplicitly undefined, and will probably segfault your program. brainf_compiler\nwill generate a warning if it can statically prove out-of-range cell\naccess.\n\n\nbrainf_compiler requires brackets to be balanced, so \n+[]]\n is rejected, unlike\nsome BF interpreters.\n\n\nFinally, brainf_compiler assumes input files are valid UTF-8.\n\n\nDiagnostics\n\n\nbrainf_compiler can report syntax errors and warnings with relevant line numbers\nand highlighting.\n\n\nNote that some warning are produced during optimization, so disabling\noptimizations will reduce warnings.\n\n\nOptimizations\n\n\nPeephole optimizations\n\n\nbrainf_compiler provides a range of peephole optimizations. We use quickcheck to\nensure our optimizations are in the optimal order (by verifying that\nour optimizer is idempotent).\n\n\nCombining Instructions\n\n\nWe combine successive increments/decrements:\n\n\n   Compile            Combine\n+++  =\n   Increment 1   =\n   Increment 3\n          Increment 1\n          Increment 1\n\n\n\n\nIf increments/decrements cancel out, we remove them entirely.\n\n\n   Compile             Combine\n+-   =\n   Increment  1    =\n   # nothing!\n          Increment -1\n\n\n\n\nWe combine pointer increments:\n\n\n   Compile            Combine\n+++  =\n   PointerIncrement 1   =\n   PointerIncrement 2\n          PointerIncrement 1\n\n\n\n\nWe do the same thing for successive sets:\n\n\n      Combine\nSet 1   =\n   Set 2\nSet 2\n\n\n\n\n\nWe combine sets and increments too:\n\n\n  Compile            Known zero       Combine\n+   =\n   Increment 1   =\n   Set 0       =\n   Set 1\n                            Increment 1\n\n\n\n\n\nWe remove increments when there's a set immediately after:\n\n\n            Combine\nIncrement 1   =\n   Set 2\nSet 2\n\n\n\n\n\nWe remove both increments and sets if there's a read immediately\nafter:\n\n\n            Combine\nIncrement 1   =\n   Read\nRead\n\n\n\n\n\nWe track the current cell position in straight-line code. If we can\ndetermine the last instruction to modify the current cell, it doesn't\nneed to be immediately previous. For example, \n+\n-\n,\n:\n\n\n                   Combine\nIncrement 1          =\n   PointerIncrement 1\nPointerIncrement 1        Increment -1\nIncrement -1              PointerIncrement -1\nPointerIncrement -1       Read\nRead\n\n\n\n\n\nLoop Simplification\n\n\n[-]\n is a common BF idiom for zeroing cells. We replace that with\n\nSet\n, enabling further instruction combination.\n\n\n   Compile              Simplify\n[-]  =\n   Loop             =\n   Set 0\n            Increment -1\n\n\n\n\nDead Code Elimination\n\n\nWe remove loops that we know are dead.\n\n\nFor example, loops at the beginning of a program:\n\n\n    Compile                  Known zero               DCE\n[\n]   =\n    Loop                 =\n     Set 0          =\n Set 0\n              DataIncrement 1           Loop\n                                            DataIncrement\n\n\n\n\nLoops following another loop (one BF technique for comments is\n\n[-][this, is+a comment.]\n).\n\n\n      Compile                 Annotate                 DCE\n[\n][\n]   =\n  Loop                =\n   Loop              =\n   Loop\n               DataIncrement 1          DataIncrement 1        DataIncrement 1\n             Loop                     Set 0                  Set 0\n               DataIncrement 1        Loop\n                                          DataIncrement 1\n\n\n\n\nLoops where the cell has previously been set to zero:\n\n\n        Compile               Simplify                 DCE\n[-]\n+\n[]  =\n   Loop              =\n    Set 0            =\n  Set 0\n                 Increment -1          DataIncrement 1      DataIncrement 1\n               DataIncrement 1         Increment 1          Increment 1\n               Increment 1             DataIncrement -1     DataIncrement -1\n               DataIncrement -1        Loop\n               Loop\n\n\n\n\nWe remove redundant set commands after loops (often generated by loop\nannotation as above).\n\n\n       Remove redundant set\nLoop           =\n   Loop\n  Increment -1        Increment -1\nSet 0\n\n\n\n\n\nWe also remove dead code at the end of a program.\n\n\n        Remove pure code\nWrite         =\n           Write\nIncrement 1\n\n\n\n\nFinally, we remove cell modifications that are immediately overwritten\nby reads, e.g. \n+,\n is equivalent to \n,\n.\n\n\nReorder with offsets\n\n\nGiven a sequence of instructions without loops or I/O, we can safely\nreorder them to have the same effect (we assume no out-of-bound cell\naccess).\n\n\nThis enables us to combine pointer operations:\n\n\n    Compile                   Reorder\n\n+\n   =\n   PointerIncrement 1   =\n    Increment 1 (offset 1)\n           Increment 1                PointerIncrement 2\n           PointerIncrement 1\n\n\n\n\nWe also ensure we modify cells in a consistent order, to aid cache\nlocality. For example, \n+\n+\n+\n writes to cell #1, then cell #0, then\ncell #2. We reorder these instructions to obtain:\n\n\nIncrement 1 (offset 0)\nIncrement 1 (offset 1)\nIncrement 1 (offset 2)\nPointerIncrement 2\n\n\n\n\nMultiply-move loops\n\n\nbrainf_compiler can detect loops that perform multiplication and converts them to\nmultiply instructions. This works for simple cases like \n[-\n++\n]\n\n(multiply by two into the next cell) as well as more complex cases\nlike \n[\n-\n-\n+++\n]\n.\n\n\nCell Bounds Analysis\n\n\nBF programs can use up to 100,000 cells, all of which must be\nzero-initialised. However, most programs don't use the whole range.\n\n\nbrainf_compiler uses static analysis to work out how many cells a BF program may\nuse, so it doesn't need to allocate or zero-initialise more memory\nthan necessary.\n\n\n only uses three cells\n\n\n\n\n[\n] uses three cells at most\n\n\n\n\n[\n]\n uses four cells at most\n\n\n\n\n[\n] may use any number of cells, so we must assume 100,000\n\n\n\n\nSpeculative Execution\n\n\nbrainf_compiler executes as much as it can at compile time. For some programs\n(such as hello_world.bf) this optimizes away the entire program to\njust writing to stdout. brainf_compiler doesn't even need to allocate memory for\ncells in this situation.\n\n\n$ cargo run -- samples/hello_world.bf -c --dump-llvm\n@known_outputs = constant [13 x i8] c\nHello World!\\0A\n\n\ndeclare i32 @write(i32, i8*, i32)\n\ndefine i32 @main() {\nentry:\n  %0 = call i32 @write(i32 0, i8* getelementptr inbounds ([13 x i8]* @known_outputs, i32 0, i32 0), i32 13)\n  ret i32 0\n}\n\n\n\n\nInfinite Loops\n\n\nbrainf_compiler sets a maximum number of execution steps, avoiding infinite loops\nhanging the compiler. As a result \n+[]\n will have \n+\n executed (so our\ninitial cell value is \n1\n and \n[]\n will be in the compiled output.\n\n\nRuntime Values\n\n\nIf a program reads from stdin, speculation execution stops. As a\nresult, \n,\n will have \n executed (setting the initial cell pointer\nto 1) and \n,\n will be in the compiled output.\n\n\nLoop Execution\n\n\nIf loops can be entirely executed at compile time, they will be\nremoved from the resulting binary. Partially executed loops will be\nincluded in the output, but runtime execution can begin at an\narbitrary position in the loop.\n\n\nFor example, consider \n+[-]+[+,]\n. We can execute \n+[-]+\n\nentirely, but \n[+,]\n depends on runtime values. The\ncompiled output contains \n[+,]\n, but we start execution at the\n\n,\n (continuing execution from where compile time execution had to\nstop).", 
            "title": "Home"
        }, 
        {
            "location": "/#brainf-compiler-and-interpreter", 
            "text": "Welcome to BrainF Compiler and Interpreter documentation.\nFor more infromation about me please visit my homepage  mrkatebzadeh.xyz .", 
            "title": "BrainF Compiler and Interpreter"
        }, 
        {
            "location": "/#what-is-brainf", 
            "text": "BrainF  is the ungodly creation of Urban M\u00fcller. It is proven to be  turing-complete  and very simple as go lang. BrainF operates on an array of memory cells, also referred to as the tape, each initially set to zero. There is a pointer, initially pointing to the first memory cell. The commands are:     Command  Description  Equivalent       Move the pointer to the right  ++ptr     Move the pointer to the left  --ptr    +  Increment the memory cell under the pointer  ++*ptr    -  Decrement the memory cell under the pointer  --*ptr    .  Output the character signified by the cell at the pointer  putchar(*ptr)    ,  Input a character and store it in the cell at the pointer  *ptr = getchar()    [  Jump past the matching ] if the cell under the pointer is 0  while (*ptr) {    ]  Jump back to the matching [ if the cell under the pointer is nonzero  }     This program prints out the words  Hello World! :  +++++ +++             Set Cell #0 to 8\n[\n   ++++               Add 4 to Cell #1; this will always set Cell #1 to 4\n  [                   as the cell will be cleared by the loop\n       ++             Add 4*2 to Cell #2\n       +++            Add 4*3 to Cell #3\n       +++            Add 4*3 to Cell #4\n       +              Add 4 to Cell #5\n       -           Decrement the loop counter in Cell #1\n  ]                   Loop till Cell #1 is zero\n   +                  Add 1 to Cell #2\n   +                  Add 1 to Cell #3\n   -                  Subtract 1 from Cell #4\n   +                 Add 1 to Cell #6\n  [ ]                 Move back to the first zero cell you find; this will\n                      be Cell #1 which was cleared by the previous loop\n   -                  Decrement the loop Counter in Cell #0\n]                     Loop till Cell #0 is zero\n\nThe result of this is:\nCell No :   0   1   2   3   4   5   6\nContents:   0   0  72 104  88  32   8\nPointer :   ^ .                     Cell #2 has value 72 which is 'H' ---.                   Subtract 3 from Cell #3 to get 101 which is 'e'\n+++++ ++..+++.          Likewise for 'llo' from Cell #3 .                     Cell #5 is 32 for the space -.                     Subtract 1 from Cell #4 for 87 to give a 'W' .                      Cell #3 was set to 'o' from the end of 'Hello'\n+++.----- -.----- ---.  Cell #3 for 'rl' and 'd' +.                    Add 1 to Cell #5 gives us an exclamation point ++.                    And finally a newline from Cell #6  We have a simple and fast interpreter and a complete compiler for BrainF.\nThe compiling phase is structured as follows:  BF source -  BF IR -  LLVM IR -  x86_32 Binary", 
            "title": "What is BrainF"
        }, 
        {
            "location": "/#getting-started", 
            "text": "Getting started is super easy. You can clone the repository:  $ git clone https://github.com/mrkatebzadeh/brainf_compiler.git", 
            "title": "Getting started"
        }, 
        {
            "location": "/#usage", 
            "text": "You will need LLVM and Rust installed to compile brainf_compiler.  $ cargo build --release  Debug builds work, but large BF programs will take a long time\nin speculative execution if brainf_compiler is compiled without optimizations. You\ncan disable this by passing  --opt=0  or  --opt=1  when running brainf_compiler.  Compiling-mode:  $ target/release/brainf_compiler -c samples/hello_world.bf\n$ ./hello_world\nHello World!  Interpreting-mode:  $ target/release/brainf_compiler -i samples/hello_world.bf\nHello World!  By default, brainf_compiler compiles programs to executables that run on the\ncurrent machine. You can explicitly specify architecture using LLVM\ntarget triples:  $ target/release/brainf_compiler -c samples/hello_world.bf --target=x86_64-pc-linux-gnu", 
            "title": "Usage"
        }, 
        {
            "location": "/#llvm-version", 
            "text": "LLVM 3.8+ is recommended, as there are known bugs with 3.7. Either\ndownload a prebuilt LLVM, or build it as follows:  $ wget http://llvm.org/pre-releases/3.8.0/rc1/llvm-3.8.0rc1.src.tar.xz\n$ tar -xf llvm-3.8.0rc1.src.tar.xz\n\n$ mkdir -p ~/tmp/llvm_3_8_build\n$ cd ~/tmp/llvm_3_8_build\n\n$ cmake -G Ninja /path/to/untarred/llvm\n$ ninja  brainf_compiler depends on llvm-sys, which compiles against whichever llvm-config  it finds.  $ export PATH=~/tmp/llvm_3_8_build:$PATH\n$ cargo build --release", 
            "title": "LLVM Version"
        }, 
        {
            "location": "/#portability", 
            "text": "brainf_compiler considers cells to be single bytes, and arithmetic wraps\naround. As a result,  -  sets cell #0 to 255.  brainf_compiler provides 100,000 cells. Accessing cells outside of this range is\nexplicitly undefined, and will probably segfault your program. brainf_compiler\nwill generate a warning if it can statically prove out-of-range cell\naccess.  brainf_compiler requires brackets to be balanced, so  +[]]  is rejected, unlike\nsome BF interpreters.  Finally, brainf_compiler assumes input files are valid UTF-8.", 
            "title": "Portability"
        }, 
        {
            "location": "/#diagnostics", 
            "text": "brainf_compiler can report syntax errors and warnings with relevant line numbers\nand highlighting.  Note that some warning are produced during optimization, so disabling\noptimizations will reduce warnings.", 
            "title": "Diagnostics"
        }, 
        {
            "location": "/#optimizations", 
            "text": "", 
            "title": "Optimizations"
        }, 
        {
            "location": "/#peephole-optimizations", 
            "text": "brainf_compiler provides a range of peephole optimizations. We use quickcheck to\nensure our optimizations are in the optimal order (by verifying that\nour optimizer is idempotent).", 
            "title": "Peephole optimizations"
        }, 
        {
            "location": "/#combining-instructions", 
            "text": "We combine successive increments/decrements:     Compile            Combine\n+++  =    Increment 1   =    Increment 3\n          Increment 1\n          Increment 1  If increments/decrements cancel out, we remove them entirely.     Compile             Combine\n+-   =    Increment  1    =    # nothing!\n          Increment -1  We combine pointer increments:     Compile            Combine\n+++  =    PointerIncrement 1   =    PointerIncrement 2\n          PointerIncrement 1  We do the same thing for successive sets:        Combine\nSet 1   =    Set 2\nSet 2  We combine sets and increments too:    Compile            Known zero       Combine\n+   =    Increment 1   =    Set 0       =    Set 1\n                            Increment 1  We remove increments when there's a set immediately after:              Combine\nIncrement 1   =    Set 2\nSet 2  We remove both increments and sets if there's a read immediately\nafter:              Combine\nIncrement 1   =    Read\nRead  We track the current cell position in straight-line code. If we can\ndetermine the last instruction to modify the current cell, it doesn't\nneed to be immediately previous. For example,  + - , :                     Combine\nIncrement 1          =    PointerIncrement 1\nPointerIncrement 1        Increment -1\nIncrement -1              PointerIncrement -1\nPointerIncrement -1       Read\nRead", 
            "title": "Combining Instructions"
        }, 
        {
            "location": "/#loop-simplification", 
            "text": "[-]  is a common BF idiom for zeroing cells. We replace that with Set , enabling further instruction combination.     Compile              Simplify\n[-]  =    Loop             =    Set 0\n            Increment -1", 
            "title": "Loop Simplification"
        }, 
        {
            "location": "/#dead-code-elimination", 
            "text": "We remove loops that we know are dead.  For example, loops at the beginning of a program:      Compile                  Known zero               DCE\n[ ]   =     Loop                 =      Set 0          =  Set 0\n              DataIncrement 1           Loop\n                                            DataIncrement  Loops following another loop (one BF technique for comments is [-][this, is+a comment.] ).        Compile                 Annotate                 DCE\n[ ][ ]   =   Loop                =    Loop              =    Loop\n               DataIncrement 1          DataIncrement 1        DataIncrement 1\n             Loop                     Set 0                  Set 0\n               DataIncrement 1        Loop\n                                          DataIncrement 1  Loops where the cell has previously been set to zero:          Compile               Simplify                 DCE\n[-] + []  =    Loop              =     Set 0            =   Set 0\n                 Increment -1          DataIncrement 1      DataIncrement 1\n               DataIncrement 1         Increment 1          Increment 1\n               Increment 1             DataIncrement -1     DataIncrement -1\n               DataIncrement -1        Loop\n               Loop  We remove redundant set commands after loops (often generated by loop\nannotation as above).         Remove redundant set\nLoop           =    Loop\n  Increment -1        Increment -1\nSet 0  We also remove dead code at the end of a program.          Remove pure code\nWrite         =            Write\nIncrement 1  Finally, we remove cell modifications that are immediately overwritten\nby reads, e.g.  +,  is equivalent to  , .", 
            "title": "Dead Code Elimination"
        }, 
        {
            "location": "/#reorder-with-offsets", 
            "text": "Given a sequence of instructions without loops or I/O, we can safely\nreorder them to have the same effect (we assume no out-of-bound cell\naccess).  This enables us to combine pointer operations:      Compile                   Reorder +    =    PointerIncrement 1   =     Increment 1 (offset 1)\n           Increment 1                PointerIncrement 2\n           PointerIncrement 1  We also ensure we modify cells in a consistent order, to aid cache\nlocality. For example,  + + +  writes to cell #1, then cell #0, then\ncell #2. We reorder these instructions to obtain:  Increment 1 (offset 0)\nIncrement 1 (offset 1)\nIncrement 1 (offset 2)\nPointerIncrement 2", 
            "title": "Reorder with offsets"
        }, 
        {
            "location": "/#multiply-move-loops", 
            "text": "brainf_compiler can detect loops that perform multiplication and converts them to\nmultiply instructions. This works for simple cases like  [- ++ ] \n(multiply by two into the next cell) as well as more complex cases\nlike  [ - - +++ ] .", 
            "title": "Multiply-move loops"
        }, 
        {
            "location": "/#cell-bounds-analysis", 
            "text": "BF programs can use up to 100,000 cells, all of which must be\nzero-initialised. However, most programs don't use the whole range.  brainf_compiler uses static analysis to work out how many cells a BF program may\nuse, so it doesn't need to allocate or zero-initialise more memory\nthan necessary.   only uses three cells  [ ] uses three cells at most  [ ]  uses four cells at most  [ ] may use any number of cells, so we must assume 100,000", 
            "title": "Cell Bounds Analysis"
        }, 
        {
            "location": "/#speculative-execution", 
            "text": "brainf_compiler executes as much as it can at compile time. For some programs\n(such as hello_world.bf) this optimizes away the entire program to\njust writing to stdout. brainf_compiler doesn't even need to allocate memory for\ncells in this situation.  $ cargo run -- samples/hello_world.bf -c --dump-llvm\n@known_outputs = constant [13 x i8] c Hello World!\\0A \n\ndeclare i32 @write(i32, i8*, i32)\n\ndefine i32 @main() {\nentry:\n  %0 = call i32 @write(i32 0, i8* getelementptr inbounds ([13 x i8]* @known_outputs, i32 0, i32 0), i32 13)\n  ret i32 0\n}", 
            "title": "Speculative Execution"
        }, 
        {
            "location": "/#infinite-loops", 
            "text": "brainf_compiler sets a maximum number of execution steps, avoiding infinite loops\nhanging the compiler. As a result  +[]  will have  +  executed (so our\ninitial cell value is  1  and  []  will be in the compiled output.", 
            "title": "Infinite Loops"
        }, 
        {
            "location": "/#runtime-values", 
            "text": "If a program reads from stdin, speculation execution stops. As a\nresult,  ,  will have   executed (setting the initial cell pointer\nto 1) and  ,  will be in the compiled output.", 
            "title": "Runtime Values"
        }, 
        {
            "location": "/#loop-execution", 
            "text": "If loops can be entirely executed at compile time, they will be\nremoved from the resulting binary. Partially executed loops will be\nincluded in the output, but runtime execution can begin at an\narbitrary position in the loop.  For example, consider  +[-]+[+,] . We can execute  +[-]+ \nentirely, but  [+,]  depends on runtime values. The\ncompiled output contains  [+,] , but we start execution at the ,  (continuing execution from where compile time execution had to\nstop).", 
            "title": "Loop Execution"
        }
    ]
}